import { Schema, model, Document, ObjectId } from 'mongoose';

export interface IStudentProgress extends Document {
  _id: ObjectId;
  assignmentId: ObjectId;
  studentId: ObjectId;
  
  // Overall Progress
  status: 'not-started' | 'in-progress' | 'completed' | 'submitted' | 'graded' | 'overdue';
  startedAt?: Date;
  completedAt?: Date;
  submittedAt?: Date;
  lastAccessedAt?: Date;
  
  // Attempts & Timing
  attempts: {
    current: number;
    total: number;
    allowed: number;
  };
  
  timing: {
    totalTimeSpent: number; // minutes
    averageSessionTime: number; // minutes
    longestSession: number; // minutes
    sessionCount: number;
    lastSessionStart?: Date;
    lastSessionEnd?: Date;
  };

  // Activity Progress
  activityProgress: Array<{
    activityId: ObjectId;
    order: number;
    status: 'not-started' | 'in-progress' | 'completed' | 'skipped';
    attempts: number;
    timeSpent: number; // minutes
    score?: number; // 0-100
    maxScore?: number;
    passed: boolean;
    startedAt?: Date;
    completedAt?: Date;
    
    // Detailed interaction data
    interactions: Array<{
      type: 'start' | 'pause' | 'resume' | 'submit' | 'hint' | 'skip' | 'retry';
      timestamp: Date;
      data?: any; // additional context data
    }>;
    
    // Responses and submissions
    responses: Array<{
      questionId?: string;
      response: any;
      isCorrect?: boolean;
      points?: number;
      timestamp: Date;
      timeTaken?: number; // seconds
    }>;
    
    // Adaptive learning data
    adaptiveData?: {
      difficultyAdjustments: Array<{
        from: string;
        to: string;
        reason: string;
        timestamp: Date;
      }>;
      personalizedHints: string[];
      skillAssessments: Array<{
        skillId: string;
        level: number; // 0-1 proficiency
        confidence: number; // 0-1
        timestamp: Date;
      }>;
    };
  }>;

  // Scoring & Grading
  grading: {
    totalScore: number; // 0-100
    maxPossibleScore: number;
    weightedScore: number; // considering activity weights
    letterGrade?: string;
    passed: boolean;
    gradedAt?: Date;
    gradedBy?: ObjectId;
    
    // Detailed scoring breakdown
    breakdown: Array<{
      activityId: ObjectId;
      score: number;
      maxScore: number;
      weight: number;
      points: number;
    }>;
    
    // Rubric scoring (if applicable)
    rubricScores?: Array<{
      criteriaId: string;
      score: number;
      maxScore: number;
      feedback?: string;
    }>;
  };

  // Feedback & Comments
  feedback: {
    instructorComments: string;
    autoGeneratedFeedback: string;
    peerFeedback?: Array<{
      fromStudentId: ObjectId;
      comment: string;
      rating?: number; // 1-5
      timestamp: Date;
    }>;
    studentReflection?: string;
    
    // AI-generated insights
    aiInsights?: {
      strengths: string[];
      areasForImprovement: string[];
      recommendations: string[];
      difficultyAssessment: 'too-easy' | 'appropriate' | 'too-hard';
      engagementLevel: number; // 0-1
      predictedPerformance?: number; // 0-100
    };
  };

  // Learning Analytics
  analytics: {
    learningPatterns: {
      preferredTimeOfDay?: 'morning' | 'afternoon' | 'evening' | 'night';
      averageSessionLength: number; // minutes
      procrastinationScore: number; // 0-1 (1 = high procrastination)
      consistencyScore: number; // 0-1 (1 = very consistent)
      focusScore: number; // 0-1 based on interaction patterns
    };
    
    cognitiveLoad: {
      estimatedLoad: number; // 0-1
      strugglingIndicators: string[];
      flowStateIndicators: string[];
      confusionPoints: Array<{
        activityId: ObjectId;
        timestamp: Date;
        description: string;
      }>;
    };
    
    skillDevelopment: Array<{
      skillId: string;
      skillName: string;
      beforeLevel: number; // 0-1
      afterLevel: number; // 0-1
      improvement: number; // difference
      confidence: number; // 0-1
    }>;
    
    motivationFactors: {
      intrinsicMotivation: number; // 0-1
      extrinsicMotivation: number; // 0-1
      challengePreference: 'easy' | 'moderate' | 'hard';
      feedbackPreference: 'immediate' | 'delayed' | 'summary';
    };
  };

  // Collaboration Data (for group assignments)
  collaboration?: {
    groupId: ObjectId;
    role?: string;
    contributionScore: number; // 0-1
    peerRatings: Array<{
      fromStudentId: ObjectId;
      categories: {
        participation: number; // 1-5
        communication: number; // 1-5
        reliability: number; // 1-5
        leadership: number; // 1-5
      };
      comments?: string;
      timestamp: Date;
    }>;
    
    interactions: Array<{
      type: 'message' | 'file-share' | 'edit' | 'review';
      withStudentId?: ObjectId;
      timestamp: Date;
      data?: any;
    }>;
  };

  // Accessibility & Accommodations
  accommodations?: {
    used: Array<{
      type: 'extra-time' | 'text-to-speech' | 'large-text' | 'color-contrast' | 'simplified-ui';
      enabled: boolean;
      settings?: any;
    }>;
    
    assistiveTechnology: {
      screenReader: boolean;
      voiceInput: boolean;
      eyeTracking: boolean;
      other?: string;
    };
    
    modifications: Array<{
      type: string;
      description: string;
      appliedAt: Date;
    }>;
  };

  // Notifications & Reminders
  notifications: {
    remindersSent: Array<{
      type: 'due-soon' | 'overdue' | 'encouragement' | 'milestone';
      sentAt: Date;
      method: 'email' | 'push' | 'in-app';
      acknowledged: boolean;
      acknowledgedAt?: Date;
    }>;
    
    preferences: {
      enabled: boolean;
      methods: ('email' | 'push' | 'in-app')[];
      frequency: 'immediate' | 'daily' | 'weekly';
    };
  };

  // Quality Assurance
  qualityMetrics: {
    dataCompleteness: number; // 0-1
    anomaliesDetected: Array<{
      type: string;
      description: string;
      severity: 'low' | 'medium' | 'high';
      timestamp: Date;
      resolved: boolean;
    }>;
    
    validationErrors: Array<{
      field: string;
      error: string;
      timestamp: Date;
    }>;
  };

  // Metadata
  metadata: {
    deviceInfo?: {
      type: 'desktop' | 'tablet' | 'mobile';
      os: string;
      browser: string;
      screenSize: string;
    };
    
    networkInfo?: {
      connectionType: string;
      averageSpeed: number; // Mbps
      disconnections: number;
    };
    
    location?: {
      timezone: string;
      country?: string;
      region?: string;
    };
  };

  // Timestamps
  createdAt: Date;
  updatedAt: Date;
  lastSyncedAt: Date;
}

const studentProgressSchema = new Schema<IStudentProgress>({
  assignmentId: { type: Schema.Types.ObjectId, ref: 'Assignment', required: true },
  studentId: { type: Schema.Types.ObjectId, ref: 'User', required: true },
  
  status: { 
    type: String, 
    enum: ['not-started', 'in-progress', 'completed', 'submitted', 'graded', 'overdue'], 
    default: 'not-started' 
  },
  startedAt: { type: Date },
  completedAt: { type: Date },
  submittedAt: { type: Date },
  lastAccessedAt: { type: Date, default: Date.now },

  attempts: {
    current: { type: Number, default: 1 },
    total: { type: Number, default: 0 },
    allowed: { type: Number, default: 3 }
  },

  timing: {
    totalTimeSpent: { type: Number, default: 0 },
    averageSessionTime: { type: Number, default: 0 },
    longestSession: { type: Number, default: 0 },
    sessionCount: { type: Number, default: 0 },
    lastSessionStart: { type: Date },
    lastSessionEnd: { type: Date }
  },

  activityProgress: [{
    activityId: { type: Schema.Types.ObjectId, ref: 'Activity', required: true },
    order: { type: Number, required: true },
    status: { 
      type: String, 
      enum: ['not-started', 'in-progress', 'completed', 'skipped'], 
      default: 'not-started' 
    },
    attempts: { type: Number, default: 0 },
    timeSpent: { type: Number, default: 0 },
    score: { type: Number, min: 0, max: 100 },
    maxScore: { type: Number, default: 100 },
    passed: { type: Boolean, default: false },
    startedAt: { type: Date },
    completedAt: { type: Date },

    interactions: [{
      type: { 
        type: String, 
        enum: ['start', 'pause', 'resume', 'submit', 'hint', 'skip', 'retry'], 
        required: true 
      },
      timestamp: { type: Date, default: Date.now },
      data: { type: Schema.Types.Mixed }
    }],

    responses: [{
      questionId: { type: String },
      response: { type: Schema.Types.Mixed, required: true },
      isCorrect: { type: Boolean },
      points: { type: Number },
      timestamp: { type: Date, default: Date.now },
      timeTaken: { type: Number } // seconds
    }],

    adaptiveData: {
      difficultyAdjustments: [{
        from: { type: String, required: true },
        to: { type: String, required: true },
        reason: { type: String, required: true },
        timestamp: { type: Date, default: Date.now }
      }],
      personalizedHints: [{ type: String }],
      skillAssessments: [{
        skillId: { type: String, required: true },
        level: { type: Number, min: 0, max: 1, required: true },
        confidence: { type: Number, min: 0, max: 1, required: true },
        timestamp: { type: Date, default: Date.now }
      }]
    }
  }],

  grading: {
    totalScore: { type: Number, default: 0, min: 0, max: 100 },
    maxPossibleScore: { type: Number, default: 100 },
    weightedScore: { type: Number, default: 0 },
    letterGrade: { type: String },
    passed: { type: Boolean, default: false },
    gradedAt: { type: Date },
    gradedBy: { type: Schema.Types.ObjectId, ref: 'User' },

    breakdown: [{
      activityId: { type: Schema.Types.ObjectId, ref: 'Activity', required: true },
      score: { type: Number, required: true },
      maxScore: { type: Number, required: true },
      weight: { type: Number, default: 1 },
      points: { type: Number, required: true }
    }],

    rubricScores: [{
      criteriaId: { type: String, required: true },
      score: { type: Number, required: true },
      maxScore: { type: Number, required: true },
      feedback: { type: String }
    }]
  },

  feedback: {
    instructorComments: { type: String, maxlength: 2000 },
    autoGeneratedFeedback: { type: String, maxlength: 1000 },
    peerFeedback: [{
      fromStudentId: { type: Schema.Types.ObjectId, ref: 'User', required: true },
      comment: { type: String, required: true, maxlength: 500 },
      rating: { type: Number, min: 1, max: 5 },
      timestamp: { type: Date, default: Date.now }
    }],
    studentReflection: { type: String, maxlength: 1000 },

    aiInsights: {
      strengths: [{ type: String }],
      areasForImprovement: [{ type: String }],
      recommendations: [{ type: String }],
      difficultyAssessment: { 
        type: String, 
        enum: ['too-easy', 'appropriate', 'too-hard'] 
      },
      engagementLevel: { type: Number, min: 0, max: 1 },
      predictedPerformance: { type: Number, min: 0, max: 100 }
    }
  },

  analytics: {
    learningPatterns: {
      preferredTimeOfDay: { 
        type: String, 
        enum: ['morning', 'afternoon', 'evening', 'night'] 
      },
      averageSessionLength: { type: Number, default: 0 },
      procrastinationScore: { type: Number, min: 0, max: 1, default: 0 },
      consistencyScore: { type: Number, min: 0, max: 1, default: 0 },
      focusScore: { type: Number, min: 0, max: 1, default: 0 }
    },

    cognitiveLoad: {
      estimatedLoad: { type: Number, min: 0, max: 1, default: 0 },
      strugglingIndicators: [{ type: String }],
      flowStateIndicators: [{ type: String }],
      confusionPoints: [{
        activityId: { type: Schema.Types.ObjectId, ref: 'Activity', required: true },
        timestamp: { type: Date, default: Date.now },
        description: { type: String, required: true }
      }]
    },

    skillDevelopment: [{
      skillId: { type: String, required: true },
      skillName: { type: String, required: true },
      beforeLevel: { type: Number, min: 0, max: 1, required: true },
      afterLevel: { type: Number, min: 0, max: 1, required: true },
      improvement: { type: Number, required: true },
      confidence: { type: Number, min: 0, max: 1, required: true }
    }],

    motivationFactors: {
      intrinsicMotivation: { type: Number, min: 0, max: 1, default: 0.5 },
      extrinsicMotivation: { type: Number, min: 0, max: 1, default: 0.5 },
      challengePreference: { 
        type: String, 
        enum: ['easy', 'moderate', 'hard'], 
        default: 'moderate' 
      },
      feedbackPreference: { 
        type: String, 
        enum: ['immediate', 'delayed', 'summary'], 
        default: 'immediate' 
      }
    }
  },

  collaboration: {
    groupId: { type: Schema.Types.ObjectId, ref: 'Group' },
    role: { type: String },
    contributionScore: { type: Number, min: 0, max: 1, default: 0 },
    peerRatings: [{
      fromStudentId: { type: Schema.Types.ObjectId, ref: 'User', required: true },
      categories: {
        participation: { type: Number, min: 1, max: 5, required: true },
        communication: { type: Number, min: 1, max: 5, required: true },
        reliability: { type: Number, min: 1, max: 5, required: true },
        leadership: { type: Number, min: 1, max: 5, required: true }
      },
      comments: { type: String, maxlength: 500 },
      timestamp: { type: Date, default: Date.now }
    }],

    interactions: [{
      type: { 
        type: String, 
        enum: ['message', 'file-share', 'edit', 'review'], 
        required: true 
      },
      withStudentId: { type: Schema.Types.ObjectId, ref: 'User' },
      timestamp: { type: Date, default: Date.now },
      data: { type: Schema.Types.Mixed }
    }]
  },

  accommodations: {
    used: [{
      type: { 
        type: String, 
        enum: ['extra-time', 'text-to-speech', 'large-text', 'color-contrast', 'simplified-ui'], 
        required: true 
      },
      enabled: { type: Boolean, required: true },
      settings: { type: Schema.Types.Mixed }
    }],

    assistiveTechnology: {
      screenReader: { type: Boolean, default: false },
      voiceInput: { type: Boolean, default: false },
      eyeTracking: { type: Boolean, default: false },
      other: { type: String }
    },

    modifications: [{
      type: { type: String, required: true },
      description: { type: String, required: true },
      appliedAt: { type: Date, default: Date.now }
    }]
  },

  notifications: {
    remindersSent: [{
      type: { 
        type: String, 
        enum: ['due-soon', 'overdue', 'encouragement', 'milestone'], 
        required: true 
      },
      sentAt: { type: Date, default: Date.now },
      method: { 
        type: String, 
        enum: ['email', 'push', 'in-app'], 
        required: true 
      },
      acknowledged: { type: Boolean, default: false },
      acknowledgedAt: { type: Date }
    }],

    preferences: {
      enabled: { type: Boolean, default: true },
      methods: [{ type: String, enum: ['email', 'push', 'in-app'] }],
      frequency: { 
        type: String, 
        enum: ['immediate', 'daily', 'weekly'], 
        default: 'daily' 
      }
    }
  },

  qualityMetrics: {
    dataCompleteness: { type: Number, min: 0, max: 1, default: 1 },
    anomaliesDetected: [{
      type: { type: String, required: true },
      description: { type: String, required: true },
      severity: { type: String, enum: ['low', 'medium', 'high'], required: true },
      timestamp: { type: Date, default: Date.now },
      resolved: { type: Boolean, default: false }
    }],

    validationErrors: [{
      field: { type: String, required: true },
      error: { type: String, required: true },
      timestamp: { type: Date, default: Date.now }
    }]
  },

  metadata: {
    deviceInfo: {
      type: { type: String, enum: ['desktop', 'tablet', 'mobile'] },
      os: { type: String },
      browser: { type: String },
      screenSize: { type: String }
    },

    networkInfo: {
      connectionType: { type: String },
      averageSpeed: { type: Number },
      disconnections: { type: Number, default: 0 }
    },

    location: {
      timezone: { type: String, default: 'UTC' },
      country: { type: String },
      region: { type: String }
    }
  },

  createdAt: { type: Date, default: Date.now },
  updatedAt: { type: Date, default: Date.now },
  lastSyncedAt: { type: Date, default: Date.now }
});

// Indexes for performance
studentProgressSchema.index({ assignmentId: 1, studentId: 1 }, { unique: true });
studentProgressSchema.index({ studentId: 1, status: 1 });
studentProgressSchema.index({ assignmentId: 1, status: 1 });
studentProgressSchema.index({ lastAccessedAt: -1 });
studentProgressSchema.index({ 'grading.totalScore': -1 });
studentProgressSchema.index({ completedAt: 1 });

// Virtual for completion percentage
studentProgressSchema.virtual('completionPercentage').get(function() {
  if (this.activityProgress.length === 0) return 0;
  
  const completed = this.activityProgress.filter(
    activity => activity.status === 'completed'
  ).length;
  
  return Math.round((completed / this.activityProgress.length) * 100);
});

// Virtual for average activity score
studentProgressSchema.virtual('averageActivityScore').get(function() {
  const scoredActivities = this.activityProgress.filter(
    activity => activity.score !== undefined
  );
  
  if (scoredActivities.length === 0) return 0;
  
  const totalScore = scoredActivities.reduce(
    (sum, activity) => sum + (activity.score || 0), 0
  );
  
  return Math.round(totalScore / scoredActivities.length);
});

// Virtual for time efficiency
studentProgressSchema.virtual('timeEfficiency').get(function() {
  // Calculate efficiency based on time spent vs. expected time
  // This would need the assignment's estimated duration
  return this.timing.totalTimeSpent > 0 ? 
    Math.min(1, 60 / this.timing.totalTimeSpent) : 0;
});

// Instance methods
studentProgressSchema.methods.startAssignment = async function(): Promise<void> {
  if (this.status === 'not-started') {
    this.status = 'in-progress';
    this.startedAt = new Date();
    this.lastAccessedAt = new Date();
    
    // Start session tracking
    this.timing.sessionCount += 1;
    this.timing.lastSessionStart = new Date();
    
    await this.save();
  }
};

studentProgressSchema.methods.completeAssignment = async function(): Promise<void> {
  this.status = 'completed';
  this.completedAt = new Date();
  this.lastAccessedAt = new Date();
  
  // End current session
  if (this.timing.lastSessionStart && !this.timing.lastSessionEnd) {
    this.endSession();
  }
  
  // Calculate final scores
  await this.calculateGrades();
  
  await this.save();
};

studentProgressSchema.methods.submitAssignment = async function(): Promise<void> {
  this.status = 'submitted';
  this.submittedAt = new Date();
  this.lastAccessedAt = new Date();
  
  if (this.status !== 'completed') {
    await this.completeAssignment();
  }
  
  await this.save();
};

studentProgressSchema.methods.startSession = async function(): Promise<void> {
  this.timing.lastSessionStart = new Date();
  this.timing.sessionCount += 1;
  this.lastAccessedAt = new Date();
  
  await this.save();
};

studentProgressSchema.methods.endSession = async function(): Promise<void> {
  if (this.timing.lastSessionStart) {
    this.timing.lastSessionEnd = new Date();
    
    const sessionDuration = Math.round(
      (this.timing.lastSessionEnd.getTime() - this.timing.lastSessionStart.getTime()) / (1000 * 60)
    );
    
    this.timing.totalTimeSpent += sessionDuration;
    this.timing.averageSessionTime = this.timing.totalTimeSpent / this.timing.sessionCount;
    this.timing.longestSession = Math.max(this.timing.longestSession, sessionDuration);
    
    await this.save();
  }
};

studentProgressSchema.methods.updateActivityProgress = async function(
  activityId: ObjectId, 
  updates: any
): Promise<void> {
  const activityIndex = this.activityProgress.findIndex(
    activity => activity.activityId.equals(activityId)
  );
  
  if (activityIndex >= 0) {
    Object.assign(this.activityProgress[activityIndex], updates);
    this.lastAccessedAt = new Date();
    await this.save();
  }
};

studentProgressSchema.methods.addInteraction = async function(
  activityId: ObjectId, 
  interaction: any
): Promise<void> {
  const activityIndex = this.activityProgress.findIndex(
    activity => activity.activityId.equals(activityId)
  );
  
  if (activityIndex >= 0) {
    this.activityProgress[activityIndex].interactions.push({
      ...interaction,
      timestamp: new Date()
    });
    
    this.lastAccessedAt = new Date();
    await this.save();
  }
};

studentProgressSchema.methods.calculateGrades = async function(): Promise<void> {
  let totalWeightedScore = 0;
  let totalWeight = 0;
  
  this.grading.breakdown = [];
  
  for (const activity of this.activityProgress) {
    if (activity.score !== undefined) {
      const weight = 1; // Default weight, would come from assignment
      const points = (activity.score / 100) * weight;
      
      this.grading.breakdown.push({
        activityId: activity.activityId,
        score: activity.score,
        maxScore: activity.maxScore || 100,
        weight,
        points
      });
      
      totalWeightedScore += points;
      totalWeight += weight;
    }
  }
  
  if (totalWeight > 0) {
    this.grading.weightedScore = (totalWeightedScore / totalWeight) * 100;
    this.grading.totalScore = this.grading.weightedScore;
    
    // Determine if passed (would get passing grade from assignment)
    this.grading.passed = this.grading.totalScore >= 70; // Default passing grade
    
    // Calculate letter grade
    this.grading.letterGrade = this.calculateLetterGrade(this.grading.totalScore);
  }
};

studentProgressSchema.methods.calculateLetterGrade = function(score: number): string {
  if (score >= 97) return 'A+';
  if (score >= 93) return 'A';
  if (score >= 90) return 'A-';
  if (score >= 87) return 'B+';
  if (score >= 83) return 'B';
  if (score >= 80) return 'B-';
  if (score >= 77) return 'C+';
  if (score >= 73) return 'C';
  if (score >= 70) return 'C-';
  if (score >= 67) return 'D+';
  if (score >= 63) return 'D';
  if (score >= 60) return 'D-';
  return 'F';
};

studentProgressSchema.methods.generateAIInsights = async function(): Promise<void> {
  // This would integrate with AI services to analyze progress patterns
  // For now, provide basic insights based on data
  
  const insights = {
    strengths: [],
    areasForImprovement: [],
    recommendations: [],
    difficultyAssessment: 'appropriate' as const,
    engagementLevel: 0.5,
    predictedPerformance: this.grading.totalScore
  };
  
  // Analyze completion patterns
  if (this.completionPercentage >= 90) {
    insights.strengths.push('Excellent completion rate');
  }
  
  if (this.timing.totalTimeSpent < 30) {
    insights.areasForImprovement.push('Consider spending more time on activities');
  }
  
  if (this.grading.totalScore < 70) {
    insights.recommendations.push('Review fundamental concepts');
    insights.recommendations.push('Seek additional help from instructor');
  }
  
  // Assess difficulty based on time and scores
  const avgScore = this.averageActivityScore;
  if (avgScore > 90 && this.timing.averageSessionTime < 15) {
    insights.difficultyAssessment = 'too-easy';
  } else if (avgScore < 60 && this.timing.averageSessionTime > 45) {
    insights.difficultyAssessment = 'too-hard';
  }
  
  // Estimate engagement based on interaction patterns
  const interactionCount = this.activityProgress.reduce(
    (sum, activity) => sum + activity.interactions.length, 0
  );
  insights.engagementLevel = Math.min(1, interactionCount / (this.activityProgress.length * 5));
  
  this.feedback.aiInsights = insights;
  await this.save();
};

// Static methods
studentProgressSchema.statics.findByAssignment = function(assignmentId: ObjectId) {
  return this.find({ assignmentId })
    .populate('studentId', 'username email firstName lastName')
    .sort({ 'grading.totalScore': -1 });
};

studentProgressSchema.statics.findByStudent = function(studentId: ObjectId, status?: string) {
  const query: any = { studentId };
  if (status) query.status = status;
  
  return this.find(query)
    .populate('assignmentId', 'title dueDate status')
    .sort({ lastAccessedAt: -1 });
};

studentProgressSchema.statics.getClassAnalytics = function(assignmentId: ObjectId) {
  return this.aggregate([
    { $match: { assignmentId } },
    {
      $group: {
        _id: null,
        totalStudents: { $sum: 1 },
        completedCount: { 
          $sum: { 
            $cond: [{ $eq: ['$status', 'completed'] }, 1, 0] 
          } 
        },
        averageScore: { $avg: '$grading.totalScore' },
        averageTime: { $avg: '$timing.totalTimeSpent' },
        passedCount: { 
          $sum: { 
            $cond: ['$grading.passed', 1, 0] 
          } 
        }
      }
    }
  ]);
};

// Pre-save middleware
studentProgressSchema.pre('save', function(next) {
  this.updatedAt = new Date();
  this.lastSyncedAt = new Date();
  
  // Auto-update status based on activity progress
  if (this.status === 'in-progress') {
    const allCompleted = this.activityProgress.every(
      activity => activity.status === 'completed' || activity.status === 'skipped'
    );
    
    if (allCompleted && this.activityProgress.length > 0) {
      this.status = 'completed';
      this.completedAt = new Date();
    }
  }
  
  next();
});

export const StudentProgress = model<IStudentProgress>('StudentProgress', studentProgressSchema);