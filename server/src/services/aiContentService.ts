import OpenAI from 'openai';
import { ActivityMongo } from '../models/ActivityMongo';
import { ActivityTemplate } from '../models/ActivityTemplate';
import { logger } from '../utils/logger';

export interface AIContentRequest {
  type: 'activity' | 'template' | 'enhancement';
  prompt: string;
  parameters: {
    category: string;
    difficulty: string;
    ageRange: { min: number; max: number };
    language: string;
    contentType: string;
    duration?: number;
    objectives?: string[];
    customRequirements?: string;
  };
  preferences: {
    provider?: 'openai' | 'anthropic' | 'huggingface';
    model?: string;
    creativity?: number; // 0-1 scale
    formatStructured?: boolean;
    includeImages?: boolean;
    includeAudio?: boolean;
  };
}

export interface AIContentResponse {
  success: boolean;
  content?: any;
  metadata: {
    provider: string;
    model: string;
    tokensUsed: number;
    generationTime: number;
    confidence: number;
  };
  suggestions?: {
    improvements: string[];
    alternatives: string[];
    relatedContent: string[];
  };
  error?: string;
}

export class AIContentService {
  private openai: OpenAI;
  private anthropicClient: any;
  private huggingfaceClient: any;

  constructor() {
    // Initialize AI providers
    if (process.env.OPENAI_API_KEY) {
      this.openai = new OpenAI({
        apiKey: process.env.OPENAI_API_KEY
      });
    }
    
    // Initialize other providers (Anthropic, HuggingFace) when available
    this.initializeProviders();
  }

  private initializeProviders(): void {
    // Initialize Anthropic if key is available
    if (process.env.ANTHROPIC_API_KEY) {
      // this.anthropicClient = new Anthropic({
      //   apiKey: process.env.ANTHROPIC_API_KEY
      // });
    }

    // Initialize HuggingFace if key is available
    if (process.env.HUGGINGFACE_API_KEY) {
      // this.huggingfaceClient = new HfInference(process.env.HUGGINGFACE_API_KEY);
    }
  }

  async generateActivity(request: AIContentRequest): Promise<AIContentResponse> {
    const startTime = Date.now();
    
    try {
      logger.info('Generating AI activity', { request });

      // Choose provider based on preferences
      const provider = request.preferences.provider || 'openai';
      
      let response: AIContentResponse;
      
      switch (provider) {
        case 'openai':
          response = await this.generateWithOpenAI(request);
          break;
        case 'anthropic':
          response = await this.generateWithAnthropic(request);
          break;
        case 'huggingface':
          response = await this.generateWithHuggingFace(request);
          break;
        default:
          throw new Error(`Unsupported AI provider: ${provider}`);
      }

      response.metadata.generationTime = Date.now() - startTime;
      
      // Post-process and validate the generated content
      if (response.success && response.content) {
        response.content = await this.postProcessContent(response.content, request);
        response.suggestions = await this.generateSuggestions(response.content, request);
      }

      return response;
    } catch (error: any) {
      logger.error('AI content generation failed', { error: error.message, request });
      
      return {
        success: false,
        error: error.message,
        metadata: {
          provider: request.preferences.provider || 'openai',
          model: request.preferences.model || 'gpt-3.5-turbo',
          tokensUsed: 0,
          generationTime: Date.now() - startTime,
          confidence: 0
        }
      };
    }
  }

  private async generateWithOpenAI(request: AIContentRequest): Promise<AIContentResponse> {
    if (!this.openai) {
      throw new Error('OpenAI not initialized. Check API key.');
    }

    const prompt = this.buildPrompt(request);
    const model = request.preferences.model || 'gpt-3.5-turbo';
    
    const completion = await this.openai.chat.completions.create({
      model,
      messages: [
        {
          role: 'system',
          content: `You are an expert educational content creator specializing in interactive learning activities for children. 
                   You create engaging, age-appropriate, and educationally sound activities that promote active learning.
                   Always respond with structured JSON format as specified in the prompt.`
        },
        {
          role: 'user',
          content: prompt
        }
      ],
      temperature: request.preferences.creativity || 0.7,
      max_tokens: 2000
    });

    const content = completion.choices[0]?.message?.content;
    if (!content) {
      throw new Error('No content generated by OpenAI');
    }

    // Parse JSON response
    let parsedContent;
    try {
      parsedContent = JSON.parse(content);
    } catch (error) {
      // If JSON parsing fails, create structured content from text
      parsedContent = this.parseUnstructuredContent(content, request);
    }

    return {
      success: true,
      content: parsedContent,
      metadata: {
        provider: 'openai',
        model,
        tokensUsed: completion.usage?.total_tokens || 0,
        generationTime: 0, // Will be set by caller
        confidence: this.calculateConfidence(parsedContent)
      }
    };
  }

  private async generateWithAnthropic(request: AIContentRequest): Promise<AIContentResponse> {
    // Placeholder for Anthropic implementation
    throw new Error('Anthropic provider not yet implemented');
  }

  private async generateWithHuggingFace(request: AIContentRequest): Promise<AIContentResponse> {
    // Placeholder for HuggingFace implementation
    throw new Error('HuggingFace provider not yet implemented');
  }

  private buildPrompt(request: AIContentRequest): string {
    const { parameters, type } = request;
    
    let basePrompt = '';
    
    if (type === 'activity') {
      basePrompt = `Create an educational activity with the following specifications:
        
        Category: ${parameters.category}
        Difficulty: ${parameters.difficulty}
        Age Range: ${parameters.ageRange.min}-${parameters.ageRange.max} years
        Language: ${parameters.language}
        Content Type: ${parameters.contentType}
        Duration: ${parameters.duration || 15} minutes
        
        Additional Requirements: ${parameters.customRequirements || 'None'}
        
        Please create a comprehensive activity and respond with the following JSON structure:
        
        {
          "title": "Activity title",
          "description": "Brief description",
          "objectives": [
            {
              "description": "Learning objective",
              "bloomLevel": "understand|apply|analyze|etc",
              "measurable": true
            }
          ],
          "instructions": {
            "teacher": "Instructions for teacher",
            "student": "Instructions for student",
            "parent": "Instructions for parent"
          },
          "contentData": {
            "introduction": "Activity introduction",
            "mainActivity": "Main activity content",
            "assessment": "Assessment method",
            "conclusion": "Activity wrap-up"
          },
          "materials": ["List of required materials"],
          "adaptations": {
            "easier": "How to make it easier",
            "harder": "How to make it harder",
            "accessibility": "Accessibility considerations"
          },
          "assessment": {
            "criteria": ["Assessment criteria"],
            "rubric": "Simple rubric description"
          },
          "extensions": ["Ideas for extending the activity"]
        }`;
    } else if (type === 'template') {
      basePrompt = `Create an activity template for the ${parameters.category} category that can be customized for different topics.
        
        The template should be flexible and reusable for various ${parameters.category} activities.
        Age Range: ${parameters.ageRange.min}-${parameters.ageRange.max} years
        Content Type: ${parameters.contentType}
        
        Respond with a template structure that includes customizable variables marked with {{variable_name}}.`;
    }
    
    if (request.preferences.includeImages) {
      basePrompt += '\n\nInclude suggestions for images, illustrations, or visual elements that would enhance the activity.';
    }
    
    if (request.preferences.includeAudio) {
      basePrompt += '\n\nInclude suggestions for audio elements like narration, sound effects, or music.';
    }
    
    basePrompt += `\n\nUser prompt: ${request.prompt}`;
    
    return basePrompt;
  }

  private parseUnstructuredContent(content: string, request: AIContentRequest): any {
    // Basic parsing for unstructured content
    // This is a fallback when JSON parsing fails
    
    const lines = content.split('\n').filter(line => line.trim());
    const activity = {
      title: this.extractTitle(lines) || `${request.parameters.category} Activity`,
      description: this.extractDescription(lines) || content.substring(0, 200),
      objectives: this.extractObjectives(lines),
      instructions: {
        teacher: this.extractInstructions(lines, 'teacher'),
        student: this.extractInstructions(lines, 'student'),
        parent: this.extractInstructions(lines, 'parent')
      },
      contentData: {
        introduction: this.extractSection(lines, 'introduction'),
        mainActivity: this.extractSection(lines, 'activity'),
        assessment: this.extractSection(lines, 'assessment'),
        conclusion: this.extractSection(lines, 'conclusion')
      },
      materials: this.extractMaterials(lines),
      adaptations: {
        easier: 'Provide more scaffolding and support',
        harder: 'Add complexity and challenge',
        accessibility: 'Ensure multi-sensory approaches'
      }
    };
    
    return activity;
  }

  private extractTitle(lines: string[]): string | null {
    for (const line of lines) {
      if (line.toLowerCase().includes('title:') || line.toLowerCase().includes('activity:')) {
        return line.split(':')[1]?.trim() || null;
      }
    }
    return null;
  }

  private extractDescription(lines: string[]): string | null {
    for (const line of lines) {
      if (line.toLowerCase().includes('description:') || line.toLowerCase().includes('summary:')) {
        return line.split(':')[1]?.trim() || null;
      }
    }
    return null;
  }

  private extractObjectives(lines: string[]): any[] {
    const objectives = [];
    let inObjectivesSection = false;
    
    for (const line of lines) {
      if (line.toLowerCase().includes('objective') || line.toLowerCase().includes('goal')) {
        inObjectivesSection = true;
        continue;
      }
      
      if (inObjectivesSection && line.trim().startsWith('-')) {
        objectives.push({
          description: line.replace('-', '').trim(),
          bloomLevel: 'understand',
          measurable: true
        });
      }
    }
    
    return objectives.length > 0 ? objectives : [{
      description: 'Students will engage with the activity content',
      bloomLevel: 'understand',
      measurable: true
    }];
  }

  private extractInstructions(lines: string[], type: string): string {
    for (const line of lines) {
      if (line.toLowerCase().includes(`${type} instruction`) || line.toLowerCase().includes(`for ${type}`)) {
        return line.split(':')[1]?.trim() || `Instructions for ${type}`;
      }
    }
    return `Follow the activity guidelines for ${type}`;
  }

  private extractSection(lines: string[], sectionName: string): string {
    for (const line of lines) {
      if (line.toLowerCase().includes(sectionName)) {
        return line.split(':')[1]?.trim() || `Content for ${sectionName}`;
      }
    }
    return `Content for ${sectionName} section`;
  }

  private extractMaterials(lines: string[]): string[] {
    const materials = [];
    let inMaterialsSection = false;
    
    for (const line of lines) {
      if (line.toLowerCase().includes('material') || line.toLowerCase().includes('supplies')) {
        inMaterialsSection = true;
        continue;
      }
      
      if (inMaterialsSection && line.trim().startsWith('-')) {
        materials.push(line.replace('-', '').trim());
      }
    }
    
    return materials.length > 0 ? materials : ['Basic materials as needed'];
  }

  private calculateConfidence(content: any): number {
    let confidence = 0.5; // Base confidence
    
    if (content.title && content.title.length > 10) confidence += 0.1;
    if (content.description && content.description.length > 50) confidence += 0.1;
    if (content.objectives && content.objectives.length > 0) confidence += 0.1;
    if (content.instructions && Object.keys(content.instructions).length >= 2) confidence += 0.1;
    if (content.contentData && Object.keys(content.contentData).length >= 3) confidence += 0.2;
    
    return Math.min(confidence, 1.0);
  }

  private async postProcessContent(content: any, request: AIContentRequest): Promise<any> {
    // Add metadata and standardize format
    content.metadata = {
      aiGenerated: true,
      provider: request.preferences.provider || 'openai',
      generatedAt: new Date(),
      version: '1.0.0'
    };
    
    // Ensure required fields exist
    if (!content.title) {
      content.title = `${request.parameters.category} Activity`;
    }
    
    if (!content.description) {
      content.description = 'AI-generated educational activity';
    }
    
    // Standardize objectives format
    if (content.objectives && Array.isArray(content.objectives)) {
      content.objectives = content.objectives.map((obj: any, index: number) => ({
        id: `obj_${index + 1}`,
        description: typeof obj === 'string' ? obj : obj.description,
        bloomLevel: obj.bloomLevel || 'understand',
        measurable: obj.measurable !== false
      }));
    }
    
    // Add default duration if not present
    if (!content.duration) {
      content.duration = {
        estimated: request.parameters.duration || 15,
        minimum: Math.floor((request.parameters.duration || 15) * 0.7),
        maximum: Math.ceil((request.parameters.duration || 15) * 1.3)
      };
    }
    
    // Add default points
    if (!content.points) {
      const difficultyPoints = {
        beginner: 5, easy: 10, medium: 20, hard: 30, expert: 50
      };
      const basePoints = difficultyPoints[request.parameters.difficulty as keyof typeof difficultyPoints] || 10;
      
      content.points = {
        base: basePoints,
        bonus: Math.floor(basePoints * 0.5),
        completion: Math.floor(basePoints * 0.3),
        mastery: Math.floor(basePoints * 1.5)
      };
    }
    
    return content;
  }

  private async generateSuggestions(content: any, request: AIContentRequest): Promise<any> {
    return {
      improvements: [
        'Consider adding more interactive elements',
        'Include assessment rubrics for better evaluation',
        'Add extension activities for advanced learners'
      ],
      alternatives: [
        'Try different content presentation formats',
        'Explore collaborative learning approaches',
        'Consider multi-modal content delivery'
      ],
      relatedContent: [
        'Similar activities in this category',
        'Prerequisite skills activities',
        'Follow-up learning opportunities'
      ]
    };
  }

  async enhanceExistingActivity(activityId: string, enhancementType: string): Promise<AIContentResponse> {
    try {
      const activity = await ActivityMongo.findById(activityId);
      if (!activity) {
        throw new Error('Activity not found');
      }

      const enhancementRequest: AIContentRequest = {
        type: 'enhancement',
        prompt: `Enhance this existing activity by ${enhancementType}`,
        parameters: {
          category: activity.category,
          difficulty: activity.difficulty,
          ageRange: activity.ageRange,
          language: activity.language,
          contentType: activity.contentType,
          duration: activity.duration.estimated,
          customRequirements: `Current activity: ${JSON.stringify(activity.contentData)}`
        },
        preferences: {
          formatStructured: true,
          creativity: 0.6
        }
      };

      const enhancement = await this.generateActivity(enhancementRequest);
      
      if (enhancement.success) {
        // Create enhanced version
        const enhancedActivity = await activity.createNewVersion({
          ...enhancement.content,
          aiGenerated: {
            ...activity.aiGenerated,
            isAiGenerated: true,
            humanReviewed: false,
            generatedAt: new Date()
          }
        });
        
        enhancement.content = enhancedActivity;
      }
      
      return enhancement;
    } catch (error: any) {
      return {
        success: false,
        error: error.message,
        metadata: {
          provider: 'openai',
          model: 'gpt-3.5-turbo',
          tokensUsed: 0,
          generationTime: 0,
          confidence: 0
        }
      };
    }
  }

  async generateFromTemplate(templateId: string, variables: any): Promise<AIContentResponse> {
    try {
      const template = await ActivityTemplate.findById(templateId);
      if (!template) {
        throw new Error('Template not found');
      }

      // Use template's generation method
      const activity = await template.generateActivity(variables);
      
      return {
        success: true,
        content: activity,
        metadata: {
          provider: 'template',
          model: 'template-engine',
          tokensUsed: 0,
          generationTime: 0,
          confidence: 0.9
        },
        suggestions: {
          improvements: ['Review generated content for accuracy'],
          alternatives: ['Try different variable values'],
          relatedContent: ['Explore other templates in this category']
        }
      };
    } catch (error: any) {
      return {
        success: false,
        error: error.message,
        metadata: {
          provider: 'template',
          model: 'template-engine',
          tokensUsed: 0,
          generationTime: 0,
          confidence: 0
        }
      };
    }
  }

  async validateAIContent(content: any): Promise<{ isValid: boolean; issues: string[]; score: number }> {
    const issues: string[] = [];
    let score = 100;

    // Check required fields
    if (!content.title || content.title.length < 5) {
      issues.push('Title is missing or too short');
      score -= 20;
    }

    if (!content.description || content.description.length < 20) {
      issues.push('Description is missing or too short');
      score -= 15;
    }

    if (!content.objectives || content.objectives.length === 0) {
      issues.push('Learning objectives are missing');
      score -= 25;
    }

    if (!content.instructions || Object.keys(content.instructions).length < 2) {
      issues.push('Instructions are incomplete');
      score -= 20;
    }

    // Check content appropriateness (basic validation)
    const inappropriateWords = ['violence', 'harmful', 'dangerous'];
    const contentText = JSON.stringify(content).toLowerCase();
    
    for (const word of inappropriateWords) {
      if (contentText.includes(word)) {
        issues.push(`Potentially inappropriate content detected: ${word}`);
        score -= 30;
      }
    }

    return {
      isValid: issues.length === 0 && score >= 70,
      issues,
      score: Math.max(0, score)
    };
  }
}

export const aiContentService = new AIContentService();