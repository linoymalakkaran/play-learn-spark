import { ObjectId } from 'mongoose';
import { Class, IClass } from '../models/Class';
import { Group, IGroup } from '../models/Group';
import { UserMongo } from '../models/UserMongo';
import { Relationship } from '../models/Relationship';
import { logger } from '../utils/logger';

export interface CreateClassData {
  name: string;
  description?: string;
  subject?: string;
  gradeLevel: string;
  settings?: {
    maxStudents?: number;
    autoApproval?: boolean;
    allowParentView?: boolean;
    public?: boolean;
    allowLateJoin?: boolean;
    requireApproval?: boolean;
  };
  schedule?: {
    days: string[];
    startTime: string;
    endTime: string;
    timezone?: string;
    recurring?: boolean;
  };
}

export interface CreateGroupData {
  name: string;
  description?: string;
  type: 'study-group' | 'project-team' | 'reading-circle' | 'skill-level' | 'custom';
  members?: ObjectId[];
  settings?: {
    maxMembers?: number;
    allowSelfJoin?: boolean;
    requireApproval?: boolean;
    isPrivate?: boolean;
  };
  color?: string;
}

export class ClassService {
  
  async createClass(teacherId: ObjectId, classData: CreateClassData): Promise<IClass> {
    const teacher = await UserMongo.findById(teacherId);
    if (!teacher || teacher.role !== 'teacher') {
      throw new Error('Only teachers can create classes');
    }

    const newClass = new Class({
      name: classData.name,
      description: classData.description,
      teacher: teacherId,
      subject: classData.subject,
      gradeLevel: classData.gradeLevel,
      settings: {
        maxStudents: 30,
        autoApproval: false,
        allowParentView: true,
        public: false,
        allowLateJoin: true,
        requireApproval: true,
        ...classData.settings
      },
      joinCode: '', // Will be generated by pre-save middleware
      schedule: classData.schedule,
      analytics: {
        totalStudents: 0,
        activeStudents: 0,
        totalAssignments: 0,
        averageCompletion: 0,
        lastActivity: new Date()
      }
    });

    // Set join code expiry to 30 days from now
    newClass.joinCodeExpiry = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000);

    await newClass.save();

    logger.info(`Class created: ${newClass._id} (${newClass.name}) by teacher ${teacher.email}`);
    return newClass;
  }

  async joinClassWithCode(joinCode: string, studentId: ObjectId): Promise<IClass> {
    const classDoc = await Class.findByJoinCode(joinCode.toUpperCase());
    if (!classDoc) {
      throw new Error('Invalid join code');
    }

    // Check if join code is expired
    if (classDoc.joinCodeExpiry && classDoc.joinCodeExpiry < new Date()) {
      throw new Error('Join code has expired');
    }

    const student = await UserMongo.findById(studentId);
    if (!student || student.role !== 'student') {
      throw new Error('Only students can join classes');
    }

    // Check if student is already enrolled
    if (classDoc.isStudentEnrolled(studentId)) {
      throw new Error('Student is already enrolled in this class');
    }

    // Check if late joining is allowed
    const now = new Date();
    const classStarted = classDoc.metadata.createdAt < new Date(now.getTime() - 24 * 60 * 60 * 1000); // 1 day ago
    if (classStarted && !classDoc.settings.allowLateJoin) {
      throw new Error('Late joining is not allowed for this class');
    }

    await classDoc.addStudent(studentId, classDoc.teacher);
    
    // Create teacher-student relationship if it doesn't exist
    await this.createTeacherStudentRelationship(classDoc.teacher, studentId);

    // Notify teacher of new enrollment (you can implement email service later)
    logger.info(`Student ${student.email} joined class ${classDoc.name}`);
    
    return classDoc;
  }

  async addStudentToClass(classId: ObjectId, studentId: ObjectId, teacherId: ObjectId): Promise<void> {
    const classDoc = await Class.findById(classId);
    if (!classDoc) {
      throw new Error('Class not found');
    }

    // Verify teacher owns the class
    if (classDoc.teacher.toString() !== teacherId.toString()) {
      throw new Error('Only the class teacher can add students');
    }

    const student = await UserMongo.findById(studentId);
    if (!student || student.role !== 'student') {
      throw new Error('Invalid student');
    }

    await classDoc.addStudent(studentId, teacherId);
    
    // Create teacher-student relationship if it doesn't exist
    await this.createTeacherStudentRelationship(teacherId, studentId);
    
    logger.info(`Teacher ${teacherId} added student ${student.email} to class ${classDoc.name}`);
  }

  async approveStudentEnrollment(classId: ObjectId, studentId: ObjectId, teacherId: ObjectId): Promise<void> {
    const classDoc = await Class.findById(classId);
    if (!classDoc) {
      throw new Error('Class not found');
    }

    if (classDoc.teacher.toString() !== teacherId.toString()) {
      throw new Error('Only the class teacher can approve enrollments');
    }

    const studentEntry = classDoc.students.find((s: any) => s.userId.toString() === studentId.toString());
    if (!studentEntry) {
      throw new Error('Student not found in class');
    }

    if (studentEntry.status !== 'pending') {
      throw new Error('Student enrollment is not pending');
    }

    studentEntry.status = 'active';
    studentEntry.approvedBy = teacherId;
    
    await classDoc.updateAnalytics();
    await classDoc.save();

    logger.info(`Student enrollment approved: ${studentId} in class ${classId}`);
  }

  async removeStudentFromClass(classId: ObjectId, studentId: ObjectId, requesterId: ObjectId): Promise<void> {
    const classDoc = await Class.findById(classId);
    if (!classDoc) {
      throw new Error('Class not found');
    }

    const requester = await UserMongo.findById(requesterId);
    if (!requester) {
      throw new Error('Requester not found');
    }

    // Check permissions
    const canRemove = 
      classDoc.teacher.toString() === requesterId.toString() || // Teacher
      studentId.toString() === requesterId.toString() || // Student themselves
      await this.isParentOfStudent(requesterId, studentId); // Parent

    if (!canRemove) {
      throw new Error('Insufficient permissions to remove student');
    }

    await classDoc.removeStudent(studentId);
    logger.info(`Student ${studentId} removed from class ${classId} by ${requester.email}`);
  }

  async getTeacherClasses(teacherId: ObjectId): Promise<IClass[]> {
    return await Class.findTeacherClasses(teacherId);
  }

  async getStudentClasses(studentId: ObjectId): Promise<IClass[]> {
    return await Class.findStudentClasses(studentId);
  }

  async getClassById(classId: ObjectId, userId: ObjectId): Promise<IClass> {
    const classDoc = await Class.findById(classId)
      .populate('teacher', 'profile email username role')
      .populate('students.userId', 'profile email username role');

    if (!classDoc) {
      throw new Error('Class not found');
    }

    // Check if user has access to this class
    const hasAccess = 
      classDoc.teacher._id.toString() === userId.toString() || // Teacher
      classDoc.isStudentEnrolled(userId) || // Student
      await this.isParentOfClassStudent(userId, classId); // Parent

    if (!hasAccess) {
      throw new Error('Access denied to this class');
    }

    return classDoc;
  }

  async updateClass(classId: ObjectId, teacherId: ObjectId, updates: Partial<CreateClassData>): Promise<IClass> {
    const classDoc = await Class.findById(classId);
    if (!classDoc) {
      throw new Error('Class not found');
    }

    if (classDoc.teacher.toString() !== teacherId.toString()) {
      throw new Error('Only the class teacher can update class details');
    }

    // Apply updates safely
    if (updates.name) classDoc.name = updates.name;
    if (updates.description !== undefined) classDoc.description = updates.description;
    if (updates.subject) classDoc.subject = updates.subject;
    if (updates.gradeLevel) classDoc.gradeLevel = updates.gradeLevel;
    if (updates.settings) {
      classDoc.settings = { ...classDoc.settings, ...updates.settings };
    }
    if (updates.schedule) {
      classDoc.schedule = { ...classDoc.schedule, ...updates.schedule };
    }

    await classDoc.save();
    logger.info(`Class updated: ${classId} by teacher ${teacherId}`);
    return classDoc;
  }

  async regenerateJoinCode(classId: ObjectId, teacherId: ObjectId): Promise<string> {
    const classDoc = await Class.findById(classId);
    if (!classDoc) {
      throw new Error('Class not found');
    }

    if (classDoc.teacher.toString() !== teacherId.toString()) {
      throw new Error('Only the class teacher can regenerate join codes');
    }

    const newCode = classDoc.generateJoinCode();
    classDoc.joinCodeExpiry = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000); // 30 days
    await classDoc.save();

    logger.info(`Join code regenerated for class ${classId}`);
    return newCode;
  }

  async archiveClass(classId: ObjectId, teacherId: ObjectId): Promise<void> {
    const classDoc = await Class.findById(classId);
    if (!classDoc) {
      throw new Error('Class not found');
    }

    if (classDoc.teacher.toString() !== teacherId.toString()) {
      throw new Error('Only the class teacher can archive classes');
    }

    classDoc.metadata.archivedAt = new Date();
    await classDoc.save();

    logger.info(`Class archived: ${classId} by teacher ${teacherId}`);
  }

  // Group Management Methods
  async createGroup(classId: ObjectId, teacherId: ObjectId, groupData: CreateGroupData): Promise<IGroup> {
    const classDoc = await Class.findById(classId);
    if (!classDoc) {
      throw new Error('Class not found');
    }

    if (classDoc.teacher.toString() !== teacherId.toString()) {
      throw new Error('Only the class teacher can create groups');
    }

    const group = new Group({
      name: groupData.name,
      description: groupData.description,
      class: classId,
      teacher: teacherId,
      type: groupData.type,
      members: (groupData.members || []).map(userId => ({
        userId,
        role: 'member',
        joinedAt: new Date(),
        status: 'active'
      })),
      settings: {
        maxMembers: 8,
        allowSelfJoin: false,
        requireApproval: true,
        isPrivate: false,
        ...groupData.settings
      },
      color: groupData.color || '#3B82F6'
    });

    await group.save();
    logger.info(`Group created: ${group._id} (${group.name}) in class ${classId}`);
    return group;
  }

  async addMemberToGroup(groupId: ObjectId, userId: ObjectId, teacherId: ObjectId, role: string = 'member'): Promise<void> {
    const group = await Group.findById(groupId).populate('class');
    if (!group) {
      throw new Error('Group not found');
    }

    // Verify teacher owns the class
    if (group.teacher.toString() !== teacherId.toString()) {
      throw new Error('Only the group teacher can add members');
    }

    // Verify user is enrolled in the class
    const classDoc = group.class as any;
    if (!classDoc.isStudentEnrolled(userId)) {
      throw new Error('User must be enrolled in the class to join a group');
    }

    await group.addMember(userId, role);
    logger.info(`User ${userId} added to group ${groupId} with role ${role}`);
  }

  async removeMemberFromGroup(groupId: ObjectId, userId: ObjectId, requesterId: ObjectId): Promise<void> {
    const group = await Group.findById(groupId);
    if (!group) {
      throw new Error('Group not found');
    }

    // Check permissions
    const canRemove = 
      group.teacher.toString() === requesterId.toString() || // Teacher
      userId.toString() === requesterId.toString(); // User themselves

    if (!canRemove) {
      throw new Error('Insufficient permissions to remove member');
    }

    await group.removeMember(userId);
    logger.info(`User ${userId} removed from group ${groupId} by ${requesterId}`);
  }

  async getClassGroups(classId: ObjectId): Promise<IGroup[]> {
    return await Group.findByClass(classId);
  }

  async getUserGroups(userId: ObjectId): Promise<IGroup[]> {
    return await Group.findUserGroups(userId);
  }

  async updateGroup(groupId: ObjectId, teacherId: ObjectId, updates: Partial<CreateGroupData>): Promise<IGroup> {
    const group = await Group.findById(groupId);
    if (!group) {
      throw new Error('Group not found');
    }

    if (group.teacher.toString() !== teacherId.toString()) {
      throw new Error('Only the group teacher can update group details');
    }

    // Apply updates safely
    if (updates.name) group.name = updates.name;
    if (updates.description !== undefined) group.description = updates.description;
    if (updates.type) group.type = updates.type;
    if (updates.color) group.color = updates.color;
    if (updates.settings) {
      group.settings = { ...group.settings, ...updates.settings };
    }

    await group.save();
    logger.info(`Group updated: ${groupId} by teacher ${teacherId}`);
    return group;
  }

  // Private helper methods
  private async createTeacherStudentRelationship(teacherId: ObjectId, studentId: ObjectId): Promise<void> {
    try {
      const existingRelationship = await Relationship.findOne({
        $or: [
          { initiator: teacherId, target: studentId, type: 'teacher-student' },
          { initiator: studentId, target: teacherId, type: 'teacher-student' }
        ]
      });

      if (!existingRelationship) {
        const relationship = new Relationship({
          type: 'teacher-student',
          initiator: teacherId,
          target: studentId,
          status: 'approved',
          permissions: {
            viewProgress: true,
            assignActivities: true,
            receiveNotifications: true,
            manageSettings: false,
            viewReports: true,
            communicateWithTeacher: true
          }
        });

        await relationship.save();
        logger.info(`Teacher-student relationship created: ${teacherId} - ${studentId}`);
      }
    } catch (error) {
      logger.error('Error creating teacher-student relationship:', error);
      // Don't throw error as this is not critical for class joining
    }
  }

  private async isParentOfStudent(parentId: ObjectId, studentId: ObjectId): Promise<boolean> {
    try {
      const relationship = await Relationship.findOne({
        initiator: parentId,
        target: studentId,
        type: 'parent-child',
        status: 'approved'
      });

      return !!relationship;
    } catch (error) {
      logger.error('Error checking parent-student relationship:', error);
      return false;
    }
  }

  private async isParentOfClassStudent(parentId: ObjectId, classId: ObjectId): Promise<boolean> {
    try {
      const classDoc = await Class.findById(classId);
      if (!classDoc) return false;

      for (const student of classDoc.students) {
        if (await this.isParentOfStudent(parentId, student.userId)) {
          return true;
        }
      }

      return false;
    } catch (error) {
      logger.error('Error checking parent-class relationship:', error);
      return false;
    }
  }

  async previewClassByJoinCode(joinCode: string, userId: ObjectId): Promise<any> {
    try {
      const classDoc = await Class.findOne({ 
        joinCode: joinCode.toUpperCase(),
        isActive: true,
        isArchived: false
      }).populate('teacher', 'name email');

      if (!classDoc) {
        throw new Error('Class not found or join code is invalid');
      }

      // Check if class is full
      if (classDoc.settings.maxStudents && classDoc.students.length >= classDoc.settings.maxStudents) {
        throw new Error('Class is full');
      }

      // Check if user is already enrolled
      const isAlreadyEnrolled = classDoc.students.some(
        student => student.userId.toString() === userId.toString()
      );

      if (isAlreadyEnrolled) {
        throw new Error('You are already enrolled in this class');
      }

      // Return safe preview data (without sensitive information)
      return {
        _id: classDoc._id,
        name: classDoc.name,
        subject: classDoc.subject,
        gradeLevel: classDoc.gradeLevel,
        description: classDoc.description,
        teacher: {
          _id: classDoc.teacher._id,
          name: classDoc.teacher.name
        },
        joinCode: classDoc.joinCode,
        settings: {
          maxStudents: classDoc.settings.maxStudents,
          requireApproval: classDoc.settings.requireApproval,
          allowLateSubmissions: classDoc.settings.allowLateSubmissions,
          color: classDoc.settings.color
        },
        schedule: classDoc.schedule,
        studentCount: classDoc.students.length,
        isActive: classDoc.isActive,
        createdAt: classDoc.createdAt
      };
    } catch (error) {
      logger.error('Error previewing class by join code:', error);
      throw error;
    }
  }

  async deleteGroup(groupId: ObjectId, teacherId: ObjectId): Promise<void> {
    try {
      const group = await Group.findById(groupId).populate('class');
      if (!group) {
        throw new Error('Group not found');
      }

      // Check if the user is the teacher of the class
      if (group.class.teacher.toString() !== teacherId.toString()) {
        throw new Error('Not authorized to delete this group');
      }

      await Group.findByIdAndDelete(groupId);
      logger.info(`Group ${groupId} deleted by teacher ${teacherId}`);
    } catch (error) {
      logger.error('Error deleting group:', error);
      throw error;
    }
  }
}

export const classService = new ClassService();